

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Estrutura matemática da MQ - parte 1 &#8212; 7600042-2023 Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'RevMQ-p1';</script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Estrutura matemática da MQ - parte 2" href="RevMQ-p2.html" />
    <link rel="prev" title="7600042 - Tópicos Especiais em Mecânica Quântica (2023)" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    7600042 - Tópicos Especiais em Mecânica Quântica (2023)
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Estrutura matemática da MQ - parte 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="RevMQ-p2.html">Estrutura matemática da MQ - parte 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="RevMQ-p3.html">Fundamentos da Mecânica Quântica</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://srmuniz.github.io/7600042-2023/intro.html" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://srmuniz.github.io/7600042-2023/intro.html/issues/new?title=Issue%20on%20page%20%2FRevMQ-p1.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/RevMQ-p1.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Estrutura matemática da MQ - parte 1</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espaco-de-estados">Espaço de estados</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espaco-vetorial-linear">Espaço vetorial linear</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espacos-de-hilbert-espacos-vetoriais-da-mq">Espaços de Hilbert: espaços vetoriais da MQ</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Espaços de Hilbert: espaços vetoriais da MQ</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#produto-interno">Produto interno</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#comprimentos-e-angulos">Comprimentos e ângulos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#expansao-de-vetores">Expansão de vetores</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#notacao-de-dirac">Notação de Dirac</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#propriedades-do-produto-interno">Propriedades do produto interno</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vetores-de-base">Vetores de base</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#procedimento-de-gram-schmidt">Procedimento de Gram-Schmidt</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algebra-de-dirac">Algebra de Dirac</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-lineares">Operadores lineares</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exemplos-importantes">Exemplos importantes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representacao-de-operadores">Representação de operadores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#valores-esperados">Valores esperados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autovalores-e-autovetores">Autovalores e autovetores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjugacao-hermitiana">Conjugação Hermitiana</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-hermitianos">Operadores Hermitianos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-normais">Operadores Normais</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-unitarios">Operadores Unitários</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#comutadores-e-anticomutadores">Comutadores e anticomutadores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjunto-completo-de-observaveis-que-comutam-ccoc">Conjunto Completo de Observáveis que Comutam (CCOC)</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <p><span class="math notranslate nohighlight">\(\newcommand{\bra}[1]{\left\langle #1 \right|}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\ket}[1]{\left| #1 \right\rangle}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\braket}[3]{\left\langle #1 \middle| #2 \middle| #3 \right\rangle}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="estrutura-matematica-da-mq-parte-1">
<h1>Estrutura matemática da MQ - parte 1<a class="headerlink" href="#estrutura-matematica-da-mq-parte-1" title="Permalink to this heading">#</a></h1>
<p>Neste capitulo, é apresentada a estrutura matemática da teoria quântica. A prioridade maior é com relação à Física e não o rigor matemático, mas, ainda assim, serão introduzidos novos conceitos e representações que serão muito úteis para expandir os horizontes da teoria, como veremos nos próximos capítulos, isso será fundamentais para entender a linguagem contemporânea da descrição de sistemas de múltiplas partículas.</p>
<section id="espaco-de-estados">
<h2>Espaço de estados<a class="headerlink" href="#espaco-de-estados" title="Permalink to this heading">#</a></h2>
<p>Resumindo o o procedimento padrão em termos das funções de ondas, podemos dizer que as soluções estacionárias <span class="math notranslate nohighlight">\(\psi_n(x)\)</span> da Equação de Schroedinger (EqS) são funções de ondas que representam os possíveis estados do sistema, com energia <span class="math notranslate nohighlight">\(E_n\)</span>.
Outra forma de dizer isso, motivada pela forma da equação <span class="math notranslate nohighlight">\(H\psi_n(x)=E_n\psi_n(x)\)</span>, é dizer que <span class="math notranslate nohighlight">\(\{\psi_n(x)\}\)</span> é o conjunto de autofunções do operador <span class="math notranslate nohighlight">\(H\)</span>, representando os autoestados do sistema com autovalores <span class="math notranslate nohighlight">\(E_n\)</span>.
Vimos nos exemplos discutidos, como no caso da caixa infinita, que <span class="math notranslate nohighlight">\(\psi_n(x)\)</span> possui uma série de propriedades interessantes e úteis. Entre elas:</p>
<p>Dentro do que vimos até aqui, podemos, ainda de uma maneira informal, dizer que as soluções estacionárias <span class="math notranslate nohighlight">\(\psi_n(x)\)</span> da EqS são funções de ondas que representam os possíveis estados do sistema, com energia <span class="math notranslate nohighlight">\(E_n\)</span>. Outra forma de dizer isso, observando a forma da equação <span class="math notranslate nohighlight">\(H\psi_n(x)=E_n\psi_n(x)\)</span>, é dizer que <span class="math notranslate nohighlight">\(\{\psi_n(x)\}\)</span> é o conjunto de autofunções do operador <span class="math notranslate nohighlight">\(H\)</span>, representando os autoestados do sistema com autovalores <span class="math notranslate nohighlight">\(E_n\)</span>. Vimos nos exemplos discutidos, como no caso da caixa infinita, que <span class="math notranslate nohighlight">\(\psi_n(x)\)</span> possui uma série de propriedades interessantes e úteis. Entre elas:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(\int \psi^*_n(x)\psi_m(x)dx=\delta_{nm}\)</span></p>
<p><span class="math notranslate nohighlight">\(\Psi(x)=\sum_n c_n \psi_n(x)\)</span></p>
<p><span class="math notranslate nohighlight">\(c_n = \int \psi^*_n(x) \Psi(x)dx\)</span> ; onde <span class="math notranslate nohighlight">\(\sum_n |c_n|^2 = 1\)</span></p>
<p><span class="math notranslate nohighlight">\(&lt;A_{_{\Psi}}&gt; = \int \Psi^*(x) A \Psi(x) dx\)</span></p>
</div></blockquote>
<p>De fato, pode-se extender e generalizar essas ideias para expressar
esses objetos em termos mais abstratos e gerais, através do conceito de
espaço vetorial linear. Como os estados <span class="math notranslate nohighlight">\(\psi_n(x)\)</span> e os operadores
(que nesse contexto serão transformações lineares) nesses estados devem
satisfazer um certas propriedades para representar um sistema físico,
esses espaços vetoriais devem ter conjunto de estruturas e propriedades
especiais que veremos logo mais. Por simplicidade, iremos nos referir a esses espaços como <em>espaços de Hilbert</em>.</p>
<p>Para deixar esse ponto mais claro, vamos relembrar/introduzir algumas definições e conceitos, para formalizar e definir melhor essa ideia.</p>
</section>
<section id="espaco-vetorial-linear">
<h2>Espaço vetorial linear<a class="headerlink" href="#espaco-vetorial-linear" title="Permalink to this heading">#</a></h2>
<p>Partido da definição mais geral e abstrata:</p>
<p><strong>Definição 1</strong></p>
<blockquote>
<div><p>Grupo comutativo sob adição, <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, com multiplicação por escalar definida sobre um campo complexo <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, satisfazendo propriedades associativa e distributiva. Os elementos do espaço <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> são chamados de <em>vetores</em> e os elementos do campo <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> são <em>escalares</em>.</p>
</div></blockquote>
<p>As propriedades associativa e distributiva da multiplicação por escalar implica:</p>
<p>Se <span class="math notranslate nohighlight">\(\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}\)</span> e <span class="math notranslate nohighlight">\(\mathcal{F}=\{\lambda,\mu,\kappa,...\}\)</span>, temos que: <span class="math notranslate nohighlight">\(\lambda(\mu\vec{v})=(\lambda\mu)\vec{v}\)</span>,<br />
<span class="math notranslate nohighlight">\(\lambda(\vec{v}+\vec{u})=\lambda\vec{v}+\lambda\vec{u}\)</span> e  <span class="math notranslate nohighlight">\((\lambda+\mu)\vec{u}=\lambda\vec{u}+\mu\vec{u}\)</span>.</p>
<p>Vale lembrar algumas outras definições (<em>Grupo</em> e <em>Campo</em>), da Algebra:</p>
<blockquote>
<div><p><strong>Grupo:</strong> Conjunto de elementos, que inclui inversos e identidade, com uma operação (<span class="math notranslate nohighlight">\(*\)</span>) fechada que satisfaz associatividade. Grupos não precisam ser comutativos, mas quando apresentam essa propriedade são chamados de grupos comutativos ou Abelianos.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><em>Fechado</em>: <span class="math notranslate nohighlight">\(\forall\, x,y \in G \rightarrow x*y \in G\)</span></p></li>
<li><p><em>Associativo</em>: <span class="math notranslate nohighlight">\(\forall\, x,y,z \in G \rightarrow (x*y)*z=x*(y*z)\)</span></p></li>
<li><p><em>Identidade</em>: <span class="math notranslate nohighlight">\(\exists\, e\in G \rightarrow e*x=x*e=x; \,\, \forall\, x \in G\)</span></p></li>
<li><p><em>Inverso</em>: <span class="math notranslate nohighlight">\(\forall\, x \in G, \exists\, x^{-1} \rightarrow (x^{-1})*x=x*(x^{-1})=e\)</span></p></li>
</ol>
</div></blockquote>
<p><strong>Campo:</strong> De maneira simples, são conjuntos de elementos onde são definidas as quatro operações aritméticas (<span class="math notranslate nohighlight">\(+\)</span>,<span class="math notranslate nohighlight">\(-\)</span>,<span class="math notranslate nohighlight">\(\times\)</span>,<span class="math notranslate nohighlight">\(\div\)</span>) de forma comutativa. Como as operações (<span class="math notranslate nohighlight">\(-\)</span>, <span class="math notranslate nohighlight">\(\div\)</span>) são, na verdade, operações inversas de (<span class="math notranslate nohighlight">\(+\)</span>,<span class="math notranslate nohighlight">\(\times\)</span>), são definidos em termos dessas duas operações.</p>
<blockquote>
<div><p>Formalmente, campos são conjuntos de elementos com operações de adição e multiplicação (<span class="math notranslate nohighlight">\(+\)</span>,<span class="math notranslate nohighlight">\(\times\)</span>) definida; sendo comutativo para (<span class="math notranslate nohighlight">\(+\)</span>) e comutativo para (<span class="math notranslate nohighlight">\(\times\)</span>) omitindo o elemento nulo (zero). Satisfaz ainda a propriedade distributiva <span class="math notranslate nohighlight">\(a\times(b+c)=a\times b + a\times c\)</span>.</p>
</div></blockquote>
<p>Campos são, portanto, dois grupos comutativos com duas operações (<span class="math notranslate nohighlight">\(+\)</span>,<span class="math notranslate nohighlight">\(\times\)</span>). Exemplos importantes são os campos dos números reais, complexos e racionais.</p>
</div></blockquote>
<p>Alternativamente, uma definição um pouco mais familiar de <strong>espaço vetorial</strong> é:</p>
<p><strong>Definição 2:</strong></p>
<blockquote>
<div><p>Conjunto <span class="math notranslate nohighlight">\(\mathcal{V}\ne\emptyset\)</span> (não vazio) de elementos, chamados vetores, que é fechado sob adição e multiplicação por um escalar de um campo complexo <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>.</p>
</div></blockquote>
<p>Ou seja, se <span class="math notranslate nohighlight">\(\mathcal{V}=\{\vec{u},\vec{v},\vec{w},...\}\)</span> e <span class="math notranslate nohighlight">\(\mathcal{F}=\{\lambda,\mu,\kappa,...\}\)</span>, temos que:
<span class="math notranslate nohighlight">\(\forall\, \vec{u},\vec{w}\in \mathcal{V}\)</span> e <span class="math notranslate nohighlight">\(\forall\, \lambda,\mu \in \mathcal{F} \rightarrow \lambda\vec{u}+\mu\vec{w} \in \mathcal{V}\)</span></p>
<p>Se o campo <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> é complexo (real) o espaço é dito ser um espaço vetorial linear complexo (real).</p>
<p>Um conjunto de vetores <span class="math notranslate nohighlight">\(\{\phi_n \}\)</span> é dito linearmente independente (LI) se não há nenhuma combinação linear não-trivial que leve ao vetor nulo, isto é:  <span class="math notranslate nohighlight">\(\sum_n c_n \phi_n = 0 \rightarrow c_n = 0\, \forall\, n\)</span>. A dimensão <span class="math notranslate nohighlight">\(d\)</span> do espaço vetorial é dada pelo número máximo de vetores LI desse espaço. Qualquer vetor do espaço pode ser escrito como uma combinação linear dos vetores da base desse espaço, formado por vetores LI do espaço.</p>
</section>
<section id="espacos-de-hilbert-espacos-vetoriais-da-mq">
<h2>Espaços de Hilbert: espaços vetoriais da MQ<a class="headerlink" href="#espacos-de-hilbert-espacos-vetoriais-da-mq" title="Permalink to this heading">#</a></h2>
<p>Na mecânica quântica são usados espaços vetoriais com algumas propriedades e estruturas adicionais, para garantir certas propriedades físicas desejáveis da teoria. É comum, principalmente entre os físicos, chamar esses estados de estados de Hilbert. Os espaços de Hilbert podem ser finitos (com dimensão <span class="math notranslate nohighlight">\(d\)</span>) ou infinitos, por exemplo, quando os vetores são funções contínuas.</p>
<p>Embora essa terminologia não seja muito precisa, dado que os
espaços vetoriais usados na MQ são apenas um tipo particular de espaço de Hilbert (neste contexto: os espaços cujos vetores são funções <em>quadrado-integráveis</em>, também chamados de espaços de Lebesgue do tipo <span class="math notranslate nohighlight">\(L_2\)</span>), nós usaremos essa “convenção”, para simplificar a linguagem.</p>
<p>Uma das estruturas adicionais dos espaços de Hilbert é o produto interno que leva dois vetores do espaço num número complexo, segundo a definição:</p>
<div class="math notranslate nohighlight">
\[\forall\, \phi, \psi \in \mathcal{H} \rightarrow (\phi,\psi) = \int \phi^*(x)\psi(x)\,dx\]</div>
<p>No caso de um espaço discreto de dimensão <span class="math notranslate nohighlight">\(d\)</span>, o produto interno é definido como</p>
<div class="math notranslate nohighlight">
\[(w,v)=\sum_{i=1}^{d} w_i^* v_i\]</div>
<p>Note que como o produto interno resulta num escalar (número) complexo, ele não é um elemento do espaço de Hilbert. O produto interno tem as seguintes propriedades:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\((\phi,\psi) =\)</span> número complexo</p>
<p><span class="math notranslate nohighlight">\((\phi,\psi) = (\psi,\phi)^*\)</span></p>
<p><span class="math notranslate nohighlight">\((\phi, c_1 \psi_1 + c_2 \psi_2 ) = c_1(\phi, \psi_1) + c_2(\phi,\psi_2 )\)</span></p>
<p><span class="math notranslate nohighlight">\((c_1 \psi_1 + c_2 \psi_2, \phi ) = c_1^* (\psi_1, \phi) + c_2^*(\psi_2, \phi)\)</span></p>
<p><span class="math notranslate nohighlight">\((\phi,\phi) \ge 0\)</span>, sendo nulo apenas quando <span class="math notranslate nohighlight">\(\phi=0\)</span></p>
</div></blockquote>
<p>Usando o produto interno, podemos definir também a norma (ou comprimento) do vetor, através do produto interno de um vetor por ele mesmo.</p>
<div class="math notranslate nohighlight">
\[||\phi|| = \int \phi^*(x)\phi(x)\,dx\]</div>
<div class="math notranslate nohighlight">
\[||v|| = \sum_{i=1}^{d} v^*_i v_i\]</div>
<p>Observe que a norma é sempre um número real, tal que <span class="math notranslate nohighlight">\(||\phi|| \ge 0\)</span> e <span class="math notranslate nohighlight">\(||v|| \ge 0\)</span></p>
<div class="tip admonition">
<p class="admonition-title">Normas dos vetores</p>
<div class="math notranslate nohighlight">
\[||\phi|| = \int \phi^*(x)\phi(x)\,dx\]</div>
<div class="math notranslate nohighlight">
\[||v|| = \sum_{i=1}^{d} v^*_i v_i\]</div>
</div>
<p>No caso em que <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> é finito, com dimensão <span class="math notranslate nohighlight">\(d\)</span>, dado um vetor <span class="math notranslate nohighlight">\(\psi\)</span> e uma base <span class="math notranslate nohighlight">\(\{ \phi_n \}\)</span>, temos que <span class="math notranslate nohighlight">\(\psi = \sum_n c_n \phi_n\)</span> e onde <span class="math notranslate nohighlight">\(c_n=(\phi_n,\psi)\)</span> e <span class="math notranslate nohighlight">\((\phi_n,\phi_m)=\delta_{nm}\)</span>.</p>
</section>
<section id="id1">
<h2>Espaços de Hilbert: espaços vetoriais da MQ<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<p>Na mecânica quântica são usados espaços vetoriais com algumas propriedades e estruturas adicionais, para garantir certas propriedades físicas desejáveis da teoria. É comum, principalmente entre os físicos, chamar esses estados de estados de Hilbert. Os espaços de Hilbert podem ser finitos (com dimensão <span class="math notranslate nohighlight">\(d\)</span>) ou infinitos, por exemplo, quando os vetores são funções contínuas.</p>
<p>Embora essa terminologia não seja muito precisa, dado que os
espaços vetoriais usados na MQ são apenas um tipo particular de espaço de Hilbert (neste contexto: os espaços cujos vetores são funções <em>quadrado-integráveis</em>, também chamados de espaços de Lebesgue do tipo <span class="math notranslate nohighlight">\(L_2\)</span>), nós usaremos essa “convenção”, para simplificar a linguagem.</p>
<section id="produto-interno">
<h3>Produto interno<a class="headerlink" href="#produto-interno" title="Permalink to this heading">#</a></h3>
<p>Uma das estruturas adicionais dos espaços de Hilbert é o produto interno que leva dois vetores do espaço num número complexo, segundo a definição:</p>
<div class="math notranslate nohighlight">
\[\forall\, \phi, \psi \in \mathcal{H} \rightarrow (\phi,\psi) = \int \phi^*(x)\psi(x)\,dx\]</div>
<p>No caso de um espaço discreto de dimensão <span class="math notranslate nohighlight">\(d\)</span>, o produto interno é definido como</p>
<div class="math notranslate nohighlight">
\[(w,v)=\sum_{i=1}^{d} w_i^* v_i\]</div>
<p>Note que o produto interno resulta num escalar complexo, que não é um elemento do espaço de Hilbert. O produto interno tem as seguintes propriedades:</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\((\phi,\psi) =\)</span> número complexo</p>
<p><span class="math notranslate nohighlight">\((\phi,\psi) = (\psi,\phi)^*\)</span></p>
<p><span class="math notranslate nohighlight">\((\phi, c_1 \psi_1 + c_2 \psi_2 ) = c_1(\phi, \psi_1) + c_2(\phi,\psi_2 )\)</span></p>
<p><span class="math notranslate nohighlight">\((c_1 \psi_1 + c_2 \psi_2, \phi ) = c_1^* (\psi_1, \phi) + c_2^*(\psi_2, \phi)\)</span></p>
<p><span class="math notranslate nohighlight">\((\phi,\phi) \ge 0\)</span>, sendo nulo apenas quando <span class="math notranslate nohighlight">\(\phi=0\)</span></p>
</div></blockquote>
</section>
<section id="comprimentos-e-angulos">
<h3>Comprimentos e ângulos<a class="headerlink" href="#comprimentos-e-angulos" title="Permalink to this heading">#</a></h3>
<p>O conceito de produto interno nos permite generalizar os conceitos de  comprimento (norma) e medidas de ângulos entre vetores em espaços de dimensões e elementos arbitrários. Embora os vetores agora não sejam mais “setas” no espaço tridimensional Euclidiano, pode-se explorar a analogia com o conceito de produto escalar (o produto interno) daquele espaço, para definir a norma do vetor, através do produto interno de um vetor por ele mesmo:</p>
<div class="math notranslate nohighlight">
\[(\phi,\phi) = \int \phi^*(x)\phi(x)\,dx = |\phi|^2\]</div>
<div class="math notranslate nohighlight">
\[(v,v) = \sum_{i=1}^{d} v^*_i v_i = |v|^2\]</div>
<div class="math notranslate nohighlight">
\[||\phi|| = \sqrt{|\phi|^2}\]</div>
<div class="math notranslate nohighlight">
\[||v|| = \sqrt{|v|^2}\]</div>
<p>Observe que a norma é sempre um número real, tal que <span class="math notranslate nohighlight">\(||\phi|| \ge 0\)</span> e <span class="math notranslate nohighlight">\(||v|| \ge 0\)</span>, conforme nos assegura a desigualdade de Schwartz:</p>
<div class="math notranslate nohighlight">
\[ |(\psi,\phi)|^2 \le (\psi,\psi)(\phi,\phi).\]</div>
<p>Também é satisfeito o teorema de desigualdade triangular:</p>
<div class="math notranslate nohighlight">
\[ ||(\psi + \phi)|| \le ||\psi|| + ||\phi|| .\]</div>
<p>Para ambos os casos, a desigualdade só é válida quando um dos vetores é múltiplo do outro.</p>
<p>Dois vetores são tido ortogonais quando seu produto interno é nulo. Da mesma forma, um conjunto de vetores <span class="math notranslate nohighlight">\(\{\phi_n\}\)</span> é dito <em>ortonormal</em> quando o produto interno entre pares de seus elementos obedece a relação <span class="math notranslate nohighlight">\((\phi_n,\phi_m)=\delta_{nm}\)</span>.</p>
</section>
<section id="expansao-de-vetores">
<h3>Expansão de vetores<a class="headerlink" href="#expansao-de-vetores" title="Permalink to this heading">#</a></h3>
<p>No caso em que <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> é finito, com dimensão <span class="math notranslate nohighlight">\(d\)</span>, dado um vetor arbitrário <span class="math notranslate nohighlight">\(\psi\)</span> e uma base <span class="math notranslate nohighlight">\(\{ \phi_n \}\)</span> de vetores linearmente independentes, podemos expressar o vetor <span class="math notranslate nohighlight">\(\psi = \sum_n c_n \phi_n\)</span>, onde <span class="math notranslate nohighlight">\(c_n=(\phi_n,\psi)\)</span> e <span class="math notranslate nohighlight">\((\phi_n,\phi_m)=\delta_{nm}\)</span>. Podemos pensar nos coeficientes <span class="math notranslate nohighlight">\(c_n\)</span> como sendo as componentes do vetor no espaço de Hilbert, análogos às componentes de um vetor no espaço Euclidiano. Porém, é importante lembrar que essas componentes são expressas por números complexos. As componente do vetor de estado têm toda a informação relativa ao estado, determinando completamente o vetor (estado) do sistema.</p>
<p>Também de modo análogo, podemos expressar as soma de dois vetore em termos dessas componentes</p>
<div class="math notranslate nohighlight">
\[\Psi_a + \Psi_b = \sum_n (a_i + b_n) \psi_n.\]</div>
<div class="math notranslate nohighlight">
\[\lambda \Psi_a= \sum_n \lambda a_i \psi_n.\]</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><strong>Pare, Pense &amp; Contemple!</strong></p>
<p>Antes de prosseguir, pare e reflita por um momento no significado e amplitude esses  resultados.
Lembre-se que o espaço <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> pode ter dimensões infinitas, tanto no número de elemento
(vetores), como nas dimensões (número de componentes) desses vetores. Esses resultados, nada óbvios,
são extremamente poderosos e úteis, justificando plenamente o tempo investido em generalizar
e abstrair a descrição dos nossos problemas usando esse formalismo.</p>
</div>
</section>
</section>
<section id="notacao-de-dirac">
<h2>Notação de Dirac<a class="headerlink" href="#notacao-de-dirac" title="Permalink to this heading">#</a></h2>
<p>Introduzimos agora a notação de Dirac, bastante popular na mecânica quântica, onde o vetor de estado é chamado de “<em>ket</em>” e representado pelo símbolo <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>. O vetor correspondente do <em>espaço dual</em> é chamado de “<em>bra</em>” é representado por <span class="math notranslate nohighlight">\(\langle\psi|\)</span>, de tal forma que o produto interno pode ser representado por <span class="math notranslate nohighlight">\((\psi,\psi)=\langle\psi|\psi\rangle\)</span>.</p>
<p>Note que <span class="math notranslate nohighlight">\(\langle\psi|=|\psi\rangle^*\)</span>, corresponde ao complexo conjugado transposto do vetor de estado <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>. Isso fica claro, quando observamos a representação matricial desse vetores. Considere, por exemplo, que o vetor de estado tenha <span class="math notranslate nohighlight">\(n\)</span> componentes (<span class="math notranslate nohighlight">\(c_1,c_2,...,c_n\)</span>). Neste caso, o “<em>ket</em>” <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> é escrito como um vetor coluna, enquanto o seu vetor dual “<em>bra</em>” é um vetor linha, conforme indicado abaixo:</p>
<div class="math notranslate nohighlight">
\[\begin{split}|\psi\rangle = 
\left[ 
\begin{array}{c} c_1\\ c_2\\ ...\\ c_n 
\end{array} 
\right] \, 
\Rightarrow \,\,\,
\langle\psi| =
\left[ 
\begin{array}{c} c_{1}^{*} &amp; c^*_2 &amp; ...&amp; c^*_n 
\end{array} 
\right].\end{split}\]</div>
<p>Nesta representação, todas as propriedades anteriores são equivalentes a operações sobre matrizes (ou vetores linha/coluna), como, por exemplo, soma (subtração), multiplicação por escalares e combinações lineares dessas operações. O produto interno (<em>“bracket”</em>), como é fácil perceber, corresponde a uma multiplicação de matrizes, resultando num escalar:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle\phi|\psi\rangle = 
\left[ \begin{array}{c} b^*_1 &amp; b^*_2 &amp; ... &amp; b^*_n \end{array} \right]
\left[ \begin{array}{c} c_1 \\ c_2 \\ ... \\ c_n \end{array} \right] 
= \begin{array}{c} b^*_1\,c_1 &amp; b^*_2\,c_2 &amp; ...&amp; b^*_n\,c_n \end{array}
= \sum_{k=1}^n b^*_k\,c_k.\end{split}\]</div>
<section id="propriedades-do-produto-interno">
<h3>Propriedades do produto interno<a class="headerlink" href="#propriedades-do-produto-interno" title="Permalink to this heading">#</a></h3>
<p>Reescrevemos aqui as propriedade dos produto interno, na notação de Dirac. Para os vetores <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> e <span class="math notranslate nohighlight">\(|\phi\rangle\)</span>, pertencentes ao espaço <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>, e os escalares <span class="math notranslate nohighlight">\(\alpha\)</span> e <span class="math notranslate nohighlight">\(\beta\)</span> do campo complexo <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, as seguintes propriedades são satisfeitas:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{c}
1.\, &amp;&amp;\langle\psi|\phi\rangle = \langle\phi|\psi\rangle ^* \\
2.\, &amp;&amp;\langle\psi|(\alpha|\phi\rangle+\beta|\eta\rangle) = 
  \alpha\langle\psi|\phi\rangle + \beta\langle\psi|\eta\rangle \\
3.\, &amp;&amp;(\alpha\langle\phi| +\beta\langle\eta|)|\psi\rangle = 
  \alpha^*\langle\phi|\psi\rangle + \beta^*\langle\eta|\psi\rangle \\
4.\, &amp;&amp;\langle\psi|\psi\rangle \ge 0 \textrm{   sendo igual só se } 
|\psi \rangle = 0 \end{array}\end{split}\]</div>
<p>Se <span class="math notranslate nohighlight">\(\langle\psi|\Phi\rangle=0\)</span>, os vetores são ortogonais. Os comprimentos (normas) dos vetores são expressos por:</p>
<p><strong>Norma do vetor</strong>:</p>
<div class="math notranslate nohighlight">
\[||\psi|| = \sqrt{\langle\psi|\psi\rangle}.\]</div>
<p><strong>Vetor normalizado</strong> quando:</p>
<div class="math notranslate nohighlight">
\[||\psi|| = \sqrt{\langle\psi|\psi\rangle}=1.\]</div>
<p><strong>Vetores ortonormais</strong>:</p>
<div class="math notranslate nohighlight">
\[\langle u_j | u_k \rangle = \delta_{jk}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split} \delta_{jk} = \left\{ \begin{array}{c} 1 &amp; \textrm{ se }j=k \\ 0 &amp; \textrm{ caso contrário}\end{array}  \right. \end{split}\]</div>
</section>
</section>
<section id="vetores-de-base">
<h2>Vetores de base<a class="headerlink" href="#vetores-de-base" title="Permalink to this heading">#</a></h2>
<p>O conjunto de vetore <span class="math notranslate nohighlight">\(\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}\)</span> formam uma base do espaço se eles satisfazem os seguinte critérios:</p>
<div class="tip admonition">
<p class="admonition-title">Critérios</p>
<ol class="arabic simple">
<li><p>É possível escrever qualquer vetor do espaço como uma combinação linear única dos vetores <span class="math notranslate nohighlight">\(\{\phi_i\}\)</span>.</p></li>
<li><p>O conjunto <span class="math notranslate nohighlight">\(\{|\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle\}\)</span> é linearmente indenpendente.</p></li>
<li><p>Satisfaz a relação de completeza.</p></li>
</ol>
</div>
<p><strong>Condição 1:</strong>
Se o conjunto <span class="math notranslate nohighlight">\(\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}\)</span> estende todo o espaço <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>, é possível escrever um vetor <span class="math notranslate nohighlight">\(|\Psi\rangle\)</span> arbitrário como uma combinção linear dos vetores da base</p>
<div class="math notranslate nohighlight">
\[ |\Psi\rangle = c_1 |\phi_1\rangle + c_2 |\phi_2\rangle + \dots + c_n |\phi_n\rangle = \sum_{i=1}^n c_i |\phi_i\rangle\]</div>
<p>onde os coeficientes da expansão são números complexos dados por</p>
<div class="math notranslate nohighlight">
\[ c_i = \langle \phi_i | \Psi \rangle.\]</div>
<p><strong>Condição 2:</strong>
A conjunto <span class="math notranslate nohighlight">\(\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}\)</span> é dito linearmente independente quando a equação</p>
<div class="math notranslate nohighlight">
\[ a_1 |\phi_1\rangle + a_2 |\phi_2\rangle + \dots + a_n |\phi_n\rangle = 0\]</div>
<p>implica que todos os coeficientes são nulos, <span class="math notranslate nohighlight">\(c_1=c_2=...=c_n=0\)</span>. Em outras palavras, não há nenhuma combinação (não trivial) que produza o vetor nulo.</p>
<blockquote>
<div><p><strong>Dimensão do espaço</strong>
O número de elementos (vetores) da base fornece a dimensão do espaço vetorial.</p>
</div></blockquote>
<p><strong>Condição 3:</strong>
Um conjunto ortonormal <span class="math notranslate nohighlight">\(\{ |\phi_1\rangle, |\phi_2\rangle, \dots,|\phi_n\rangle \}\)</span> constitue uma base se e somente se satisfaz a <strong>relação de completeza</strong></p>
<div class="math notranslate nohighlight">
\[ \sum_{i=1}^n |\phi_i\rangle \langle \phi_i| = 1 \]</div>
<section id="procedimento-de-gram-schmidt">
<h3>Procedimento de Gram-Schmidt<a class="headerlink" href="#procedimento-de-gram-schmidt" title="Permalink to this heading">#</a></h3>
<p>Se tivermos um conjunto de vetores <span class="math notranslate nohighlight">\(\{ |u_i\rangle \}\)</span> que não é ortonormal, é possível usar este procedimento para construir uma base ortonormal Para simplificar o entendimento do processo, iremos considerar um exemplo com 3 vetores de base (espaço de dimensção 3).
Começamos selecionando um dos vetores do conjunto <span class="math notranslate nohighlight">\(\{ |u_i\rangle \}\)</span> e  definindo o vetor:</p>
<div class="math notranslate nohighlight">
\[ |w_1\rangle = |u_1\rangle  \]</div>
<p>A partir disso, constroi-se sucessivamente os vetores seguintes, subtraindo as componentes de <span class="math notranslate nohighlight">\(|w_1\rangle\)</span> em <span class="math notranslate nohighlight">\(|u_1\rangle\)</span>, conforme:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{c}
&amp;&amp;|w_2 \rangle =&amp; |u_2\rangle - \frac{\langle w_1 | u_2 \rangle}{\langle w_1 | w_1 \rangle} |w_1\rangle \\ \\
&amp;&amp;|w_3\rangle =&amp; |u_3\rangle - \frac{\langle w_1 | u_3 \rangle }{\langle w_1 | w_1 \rangle} |w_1\rangle - \frac{\langle w_2 | u_3 \rangle }{\langle w_2 | w_2 \rangle} |w_2\rangle \end{array}\end{split}\]</div>
<p>Finalmente, para obter um conjunto ortonormal <span class="math notranslate nohighlight">\(\{ |k_i\rangle \}\)</span>, nós podemos normalizar cada um dos vetores <span class="math notranslate nohighlight">\(|w_i\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[|k_1\rangle = \frac{ |w_1 \rangle }{\langle w_1 | w_1 \rangle}; \,
|k_2\rangle = \frac{ |w_2 \rangle }{\langle w_2 | w_2 \rangle}; \,
|k_3\rangle = \frac{ |w_3 \rangle }{\langle w_3 | w_3 \rangle}\]</div>
</section>
<section id="algebra-de-dirac">
<h3>Algebra de Dirac<a class="headerlink" href="#algebra-de-dirac" title="Permalink to this heading">#</a></h3>
<p>Vejamos como expressar vetores inteiramente em termos do <em>kets</em> da base e manipular <em>bras</em> e <em>kets</em> de forma algébrica.</p>
<p><strong>Representando um <em>ket</em> como <em>bra</em></strong>
Para obter o <em>bra</em> correspondente a um dado <em>ket</em>, <span class="math notranslate nohighlight">\(| \phi\rangle = \alpha |\psi\rangle\)</span>, basta tomar o complexo conjugado:</p>
<div class="math notranslate nohighlight">
\[\langle \phi|  = (\alpha |\psi\rangle)^* = \alpha \langle \psi| \]</div>
<p>podemos também escrever <span class="math notranslate nohighlight">\(|\alpha \psi\rangle = \alpha |\psi\rangle\)</span>. O mesmo pode ser feito para o <em>bra</em>, mas deve-se tomar um cuidado extra, neste caso:</p>
<div class="math notranslate nohighlight">
\[ \langle \alpha \psi| = \alpha^* \langle \psi|\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Suponha que <span class="math notranslate nohighlight">\(\{ |u_1 \rangle, |u_2 \rangle, |u_3 \rangle \}\)</span> seja uma base ortonormal. Nesta base temos:</p>
<div class="math notranslate nohighlight">
\[ | \psi \rangle = 2i |u_1 \rangle - 3|u_2 \rangle + i|u_3 \rangle \]</div>
<div class="math notranslate nohighlight">
\[ | \phi\rangle = 3 |u_1 \rangle - 2|u_2 \rangle + 4|u_3 \rangle \]</div>
<blockquote>
<div><p class="rubric">RESOLVA:</p>
<p>a) Ache <span class="math notranslate nohighlight">\(\langle \psi|\)</span> e <span class="math notranslate nohighlight">\(\langle \phi|\)</span>.</p>
<p>b) Calcule o produto interno <span class="math notranslate nohighlight">\(\langle \phi|\psi\rangle\)</span> e mostre que igual seu conjugado.</p>
<p>c) Sendo <span class="math notranslate nohighlight">\(a = 3 + 3i\)</span>, calcule <span class="math notranslate nohighlight">\(|a\psi\rangle\)</span>.</p>
<p>d) Ache as expressões de <span class="math notranslate nohighlight">\(|\psi+\phi\rangle\)</span> e  <span class="math notranslate nohighlight">\(|\psi-\phi\rangle\)</span></p>
<p>e) Calcule <span class="math notranslate nohighlight">\(\langle a \psi|\)</span> e compare com <span class="math notranslate nohighlight">\(a^* \langle \psi|\)</span>.</p>
<p>f) Normalize o vetor  <span class="math notranslate nohighlight">\(| \psi \rangle\)</span>.</p>
</div></blockquote>
</div>
<hr class="docutils" />
<p><strong>Encontrando os coeficientes da expansão</strong></p>
<p>Da mesma forma que fazemos os vetores do espaço Euclidiano, para encontrar as componentes de um vetor no espaço de Hilbert basta fazer o produto escalar (interno) do vetor com o correspondente verto da base. Em notação de Dirac, se o vetor é dado por
$<span class="math notranslate nohighlight">\(
|\psi\rangle=c_{1}\left|u_{1}\right\rangle+c_{2}\left|u_{2}\right\rangle+\cdots+c_{n}\left|u_{n}\right\rangle=\sum_{i=1}^{n} c_{i}\left|u_{i}\right\rangle
\)</span><span class="math notranslate nohighlight">\(  
os coeficientes são dados por
\)</span><span class="math notranslate nohighlight">\(
c_i = \left\langle\ u_i | \psi \right\rangle
\)</span>$
que podem ser convenientemente escritos na forma</p>
<div class="math notranslate nohighlight">
\[\begin{split}
| \psi \rangle \rightarrow\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \vdots \\ \left\langle u_{n} | \psi\right\rangle \end{array} \right) = 
\left(\begin{array}{c} c_{1} \\ c_{2} \\ \vdots \\ c_{n} \end{array}\right)
\end{split}\]</div>
<p>Note, porém, que um vetor pode ser escrito em termos de diversas bases diferentes (o vetor tem existência independentemente da base) e em cada uma delas os valores das componentes serão diferentes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Exemplo</strong></p>
<p>Considere o vetor abaixo, expresso em termos de uma base ortonormal:</p>
<div class="math notranslate nohighlight">
\[ |\psi\rangle=2 i\left|u_{1}\right\rangle-3\left|u_{2}\right\rangle+i\left|u_{3}\right\rangle\]</div>
</div>
<p>Neste caso, o vetor coluna dos coeficientes representando <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> é dado por</p>
<div class="math notranslate nohighlight">
\[\begin{split}
|\psi\rangle = 
\left( \begin{array}{c} \left\langle u_{1} | \psi\right\rangle \\ \left\langle u_{2} | \psi\right\rangle \\ \left\langle u_{3} |\psi\right\rangle \end{array}\right) = 
\left( \begin{array}{c} 2 i \\ -3 \\ i \end{array} \right).
\end{split}\]</div>
<p>Da mesma forma, o vetor dual (”<em>bra</em>”) correspondente ao vetor <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> pode ser representado na forma de um vetor linha</p>
<div class="math notranslate nohighlight">
\[
\left\langle\psi\left|=\left(\left\langle\psi | u_{1}\right\rangle\left\langle\psi | u_{2}\right\rangle\left\langle\psi | u_{3}\right\rangle\right)=\left(\left\langle u_{1} | \psi\right\rangle^{*}\left\langle u_{2} | \psi\right\rangle^{*}\left\langle u_{3} | \psi\right\rangle^{*}\right)\right.\right.
\]</div>
<p>e portanto</p>
<div class="math notranslate nohighlight">
\[
\langle\psi|=\left((2 i)^{*}(-3)^{*}(i)^{*}\right)=(-2 i-3-i).
\]</div>
</section>
</section>
<section id="operadores-lineares">
<h2>Operadores lineares<a class="headerlink" href="#operadores-lineares" title="Permalink to this heading">#</a></h2>
<p>Grandezas físicas observáveis, que podem ser medidas no laboratório, como posição e momento, são representados dentro da estrutura matemática da mecânica quântica por operadores lineares num espaço vetorial de Hilbert. Matematicamente, esses operadores são mapas que levam (transformam) um vetor em outro vetor. Isto é, são receitas ou regras de transformação de um dado vetor num novo vetor, geralmente diferente do primeiro. Frequentemente usa-se como símbolo uma letra maiúscula com “chapel” (sinal circunflexo) sobre a letra para indicar um operador. Assim, na notação de Dirac, escreve-se, por exemplo:
$<span class="math notranslate nohighlight">\(
\hat{T}|\psi\rangle=|\phi \rangle.
\)</span>$</p>
<p>Os operadores que mais nos interessam na MQ são os operadores lineares. Um operador <span class="math notranslate nohighlight">\(\hat{T}:\mathcal{H}\rightarrow\mathcal{H}\)</span> é linear no espaço <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> se, dados escalares <span class="math notranslate nohighlight">\(\alpha, \beta \in \mathbb{C}\)</span> e vetores <span class="math notranslate nohighlight">\(|u\rangle, |v\rangle \in \mathcal{H}\)</span>, ele satisfaz a relação:
$<span class="math notranslate nohighlight">\(
\hat{T}(\alpha|u\rangle+\beta|v\rangle)=\alpha\, \hat{T}|u\rangle+\beta\, \hat{T}|v\rangle.
\)</span>$</p>
<p>Além disso, os operadores lineares também satisfazem as seguintes relações:</p>
<div class="math notranslate nohighlight">
\[
(\hat{T}+\hat{S})\ket{u}=\hat{T}\ket{u} + \hat{S}\ket{u}
\]</div>
<div class="math notranslate nohighlight">
\[ 
(\hat{T}\,\hat{S})\ket{u}=\hat{T}(\hat{S}\ket{u})
\]</div>
<p>Operadores atuam tanto nos vetores <em>kets</em> como nos vetores duais <em>bras</em>, seguindo a seguinte notação (atenção para a ordem!):
$<span class="math notranslate nohighlight">\( 
\hat{T}\ket{u} \quad \text{ ou } \quad \bra{u} \hat{T}
\)</span><span class="math notranslate nohighlight">\(
mas nunca \)</span>(,\ket{u} \hat{T},)<span class="math notranslate nohighlight">\( ou \)</span>(,\hat{T} \bra{u},)$, que são formas incorretas (inválidas)!</p>
<section id="exemplos-importantes">
<h3>Exemplos importantes<a class="headerlink" href="#exemplos-importantes" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p><strong>Operador Identidade:</strong> o operador mais simples
$<span class="math notranslate nohighlight">\(
\mathbf{\hat{1}}\ket{u}=\ket{u}
\)</span>$</p></li>
<li><p><strong>Produto externo (definição):</strong> o produto externo entre <em>kets</em> e <em>bras</em> é dado por
$<span class="math notranslate nohighlight">\(
\ket{\psi}\bra{\phi} = \hat{P}
\)</span>$
note que o produto externo resulta num operador e não num escalar! Essa construção será muito útil, como veremos adiante.</p></li>
<li><p><strong>Operador projetor:</strong> usando o produto externo, podemos calcular as projeções de um dado vetor numa certa direção <span class="math notranslate nohighlight">\(\ket{u_i}\)</span>, ou numa base <span class="math notranslate nohighlight">\(\{ u_i \}\)</span>, fazendo</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{ll}
\hat{P}_{u_i} = | u_i \rangle \langle u_i |  &amp;\rightarrow \quad \hat{P}_{u_i} | \chi\rangle = | u_i \rangle (\langle u_i |\chi\rangle) = \beta | u_i \rangle \\
\hat{P}_{u} = \sum_i | u_i \rangle \langle u_i |  &amp;\rightarrow \quad  {P}_{u} | \chi\rangle = \sum_i \,c_i | u_i \rangle = | \chi\rangle
\end{array}
\end{split}\]</div>
<ul class="simple">
<li><p><strong>Relação de completeza:</strong> usando os resultados anteriores podemos observar que</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
|\psi\rangle=\sum_{i=1}^{n}c_i\left|u_{i}\right\rangle = \sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i} | \psi\right\rangle=\left(\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right|\right)|\psi\rangle
\]</div>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^{n}\left|u_{i}\right\rangle\left\langle u_{i}\right| = \mathbf{\hat{1}}
\]</div>
</section>
<section id="representacao-de-operadores">
<h3>Representação de operadores<a class="headerlink" href="#representacao-de-operadores" title="Permalink to this heading">#</a></h3>
<p>A operação matemática de transformar um vetor de um espaço vetorial linear num outro vetor, através da ação de um operador linear, pode ser representada de várias formas. Uma delas é a representação matricial, onde os operadores são representados por matrizes quadradas e os vetores por matrizes linhas e colunas. Neste caso, a transformação linear torna-se uma mera multiplicação dessas matrizes.</p>
<p>É importante lembrar que, da mesma forma que os vetores do espaço, os operadores têm existência e significado próprios no espaço vetorial e sua ação independe da representação ou da base escolhida. Por outro lado, sua representação matricial, em geral, depende da base escolhida. Devemos lembrar, porém, que a forma matricial é apenas uma das representações possíveis de um operador linear.</p>
<p><strong>Representação matricial</strong></p>
<p>A matriz de um operador numa dada base pode ser obtida a partir da ação do operador em cada vetor da base. Assim, se <span class="math notranslate nohighlight">\(\{ u_i \}\)</span> representa o conjunto de vetores da base, as componentes do operador <span class="math notranslate nohighlight">\(\hat{T}\)</span> podem ser obtidas através da operação</p>
<div class="math notranslate nohighlight">
\[
T_{i j}=\left\langle u_{i}|\hat{T}| u_{j}\right\rangle.
\]</div>
<p>Em um espaço vetorial de dimensão n, as componentes do operador podem ser arranjadas na forma de uma matriz quadrada <span class="math notranslate nohighlight">\(n \times n\)</span>, onde <span class="math notranslate nohighlight">\(T_{i j}\)</span> representa o elemento na linha <span class="math notranslate nohighlight">\(i\)</span> e coluna <span class="math notranslate nohighlight">\(j\)</span>, conforme:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\hat{T} \rightarrow\left(T_{i j}\right) &amp;=\left(\begin{array}{cccc}
T_{11} &amp; T_{12} &amp; \dots &amp; T_{1 n} \\
T_{21} &amp; T_{22} &amp; \dots &amp; T_{2 n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
T_{n 1} &amp; T_{n 2} &amp; \dots &amp; T_{n n}
\end{array}\right) \\
&amp;=\left(\begin{array}{cccc}
\left\langle u_{1}|\hat{T}| u_{1}\right\rangle &amp; \left\langle u_{1}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{1}|\hat{T}| u_{n}\right\rangle \\
\left\langle u_{2} \hat{T} | u_{1}\right\rangle &amp; \left\langle u_{2}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{2}|\hat{T}| u_{n}\right\rangle \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\left\langle u_{n}|\hat{T}| u_{1}\right\rangle &amp; \left\langle u_{n}|\hat{T}| u_{2}\right\rangle &amp; \dots &amp; \left\langle u_{n}|\hat{T}| u_{n}\right\rangle
\end{array}\right)
\end{aligned}
\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Exercício sugerido</strong></p>
<p>Suponha uma base ortonormal <span class="math notranslate nohighlight">\(\left\{\left|u_{1}\right\rangle,\left|u_{2}\right\rangle,\left|u_{3}\right\rangle\right\}\)</span>, um operador <span class="math notranslate nohighlight">\(\hat{A}\)</span> cuja a ação é dada por:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{l}
\hat{A}\left|u_{1}\right\rangle=2\left|u_{1}\right\rangle; \\
\hat{A}\left|u_{2}\right\rangle=3\left|u_{1}\right\rangle-i\left|u_{3}\right\rangle; \\
\hat{A}\left|u_{3}\right\rangle=-\left|u_{2}\right\rangle
\end{array}
\end{split}\]</div>
<p>Escreve a matriz que representa o operador nesta base.</p>
</div>
<p><strong><em>Definição</em> : Traço de um operador</strong></p>
<p>O traço de um operador <span class="math notranslate nohighlight">\(\hat{T}\)</span>, denotado por <span class="math notranslate nohighlight">\(\text{Tr}(\hat{T})\)</span>, é definido como sendo a soma dos elementos na diagonal principal da matriz que o representa</p>
<div class="math notranslate nohighlight">
\[
\text{Tr}(\hat{T})=T_{11}+T_{22}+\ldots+T_{n n}=\sum_{i=1}^{n} T_{i i}.
\]</div>
<p>Alternativamente, o traço também pode ser escrito como:</p>
<div class="math notranslate nohighlight">
\[
\text{Tr}(\hat{T})=\left\langle u_{1}|\hat{T}| u_{2}\right\rangle+\left\langle u_{2}|\hat{T}| u_{2}\right\rangle+\ldots+\left\langle u_{n}|\hat{T}| u_{n}\right\rangle=\sum_{i=1}^{n}\left\langle u_{i}|\hat{T}| u_{i}\right\rangle
\]</div>
<p>!!! question “Exercício sugerido”
O traço de um operador obedece uma relação cíclica, como indicado
$<span class="math notranslate nohighlight">\(
    \operatorname{Tr}(A B C)=\operatorname{Tr}(B C A)=\operatorname{Tr}(C A B)
    \)</span><span class="math notranslate nohighlight">\(
    Prove isso para o caso de dois operadores \)</span>A<span class="math notranslate nohighlight">\( e \)</span>B<span class="math notranslate nohighlight">\(, i.e. prove que \)</span>\operatorname{Tr}(A B)=\operatorname{Tr}(B A)$</p>
</section>
<section id="valores-esperados">
<h3>Valores esperados<a class="headerlink" href="#valores-esperados" title="Permalink to this heading">#</a></h3>
<p>O valore esperado de um operador com relação a um estado <span class="math notranslate nohighlight">\(\Psi\)</span> é dado por</p>
<div class="math notranslate nohighlight">
\[
\langle\hat{A}\rangle=\langle\Psi|\hat{A}| \Psi\rangle
\]</div>
<p>!!! question “Exercício sugerido”
Considere uma partícula no estado
$<span class="math notranslate nohighlight">\(
    |\Psi\rangle=2 i\left|u_{1}\right\rangle-\left|u_{2}\right\rangle+4 i\left|u_{3}\right\rangle
    \)</span><span class="math notranslate nohighlight">\(
    e um operador
    \)</span><span class="math notranslate nohighlight">\(
    \hat{A}=\left|u_{1}\right\rangle\left\langle u_{1}| -2 i| u_{1}\right\rangle\left\langle u_{2}|+| u_{3}\right\rangle\left\langle u_{3}\right|
    \)</span><span class="math notranslate nohighlight">\(
    Considerando que \)</span>{ |u_i\rangle }<span class="math notranslate nohighlight">\( é uma base ortonormal, calcule \)</span>\langle \hat{A} \rangle$ nesse estado.</p>
</section>
<section id="autovalores-e-autovetores">
<h3>Autovalores e autovetores<a class="headerlink" href="#autovalores-e-autovetores" title="Permalink to this heading">#</a></h3>
<p>Quando um operador age sobre um dado vetor (estado) e o resultado é o mesmo vetor (estado) multiplicado por um escalar, o vetor é chamado de autovetor (autoestado) e o escalar de autovalor. Assim, por exemplo, no caso da energia total
$<span class="math notranslate nohighlight">\(
\hat{H}|\psi_n\rangle = E_n |\psi_n \rangle
\)</span>$</p>
<p>No contexto da mecânica quântica, operadores de observáveis físicos têm como autovalores o conjunto de todas as possíveis medidas daquela grandeza física, num dado sistema quântico. Os autovetores de um operador são autoestados do sistema quântico e são muito importantes, pois esses autovetores formam uma base do espaço e permitem representar qualquer estado do sistema. A seguir temos uma breve revisão de como calcular autovalores e autovetores, a partir de conceitos e métodos de Algebra Linear.</p>
<p><strong>Cálculo dos autovalores</strong></p>
<p>Dado um operador linear <span class="math notranslate nohighlight">\(\hat{T}\)</span>, como já vimos, pode-se sempre representá-lo por uma matriz <span class="math notranslate nohighlight">\(T\)</span>. O conjunto de autovalores <span class="math notranslate nohighlight">\(\lambda\)</span> dessa matriz podem ser determinados através da <em>equação característica</em> (também chamada de <em>equação secular</em>), para o determinante abaixo:
$<span class="math notranslate nohighlight">\(
\operatorname{det}(T-\lambda I)=0\)</span><span class="math notranslate nohighlight">\(
onde \)</span>I=(\mathbf{\hat{1}})<span class="math notranslate nohighlight">\( é a matriz identidade. A solução da equação característica fornece os autovalores \)</span>\lambda$, que são as raízes do <em>polinômio</em> (<em>característico</em>), indicado acima.</p>
<p>!!! question “Exercício sugerido”
Escreva o equação característica e ache os autovalores da matriz</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$$
A = 
\begin{pmatrix}
7i &amp; -1 \\ 
2 &amp; -6i
\end{pmatrix} 
$$
</pre></div>
</div>
<p><strong>Cálculo dos autovetores</strong></p>
<p>A partir dos autovalores pode-se determinar os autovetores da matriz <span class="math notranslate nohighlight">\(T\)</span>, que pode ser então escrita na forma diagonal. Para ilustrar melhor isso, usaremos um exemplo, a partir do problema proposto a seguir.</p>
<p>!!! question “Exercício sugerido”
Considere o operador <span class="math notranslate nohighlight">\(\hat{T}=\ket{\phi_1}\bra{\phi_1}+2\ket{\phi_1}\bra{\phi_2}+\ket{\phi_2}\bra{\phi_1}\)</span>, expresso numa base ortonormal. Ache a matriz <span class="math notranslate nohighlight">\(T\)</span>, que representa o operador nesta base, e determine os autovetores normalizados do operador, com seus autovalores. Considere que o espaço é bidimensional.</p>
<p>Antes de seguir, você deve resolver o problema proposto acima, em detalhe, pelo menos até onde puder, para ter certeza de que está entendo todos os passos necessários à resolução do problema. Ao fazer isso irá encontrar os valores que usaremos na resolução que exemplificada o cálculo de um dos autovetores, a seguir</p>
<p>!!! example “Exemplo: resolução dos autovetores”<br />
Os autovalores do problema anterior são <span class="math notranslate nohighlight">\(\lambda_1=2\)</span> e <span class="math notranslate nohighlight">\(\lambda_2=-1\)</span>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Substitui-se, então, esses valores, um de cada vez, na equação de autovalores $\hat{T}\ket{u_i}=\lambda_i \ket{u_i}$ para determinar os autovetores $\{ \ket{u_1},\ket{u_2} \}$, como é mostrado abaixo para $\ket{u_2}$.

$$
\begin{pmatrix}
1 &amp; 2 \\ 
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
a \\ 
b
\end{pmatrix} = -
\begin{pmatrix}
a \\
b
\end{pmatrix}
$$

$$
\Rightarrow a + 2b = -a, \text{ ou } b = -a.
$$

portanto,

$$
\ket{u_2}= 
\begin{pmatrix}
a \\
-a
\end{pmatrix}.
$$

Normalizando o vetor temos:

$$
\bra{u_2} u_2 \rangle = 1 \rightarrow 2a^2 = 1 \Rightarrow a=\frac{1}{\sqrt{2}},
$$

portanto, finalmente, temos:

$$
\ket{u_2} = 
\frac{1}{\sqrt{2}}
\begin{pmatrix}
1 \\
-1
\end{pmatrix}.
$$

Verifique agora que 

$$ 
\ket{u_1} = \frac{1}{\sqrt{5}} 
\begin{pmatrix} 
2 \\ 
1 
\end{pmatrix}.
$$
</pre></div>
</div>
</section>
<section id="conjugacao-hermitiana">
<h3>Conjugação Hermitiana<a class="headerlink" href="#conjugacao-hermitiana" title="Permalink to this heading">#</a></h3>
<p>Até agora vimos que um operador age num <em>ket</em> para produzir um novo <em>ket</em>, de acordo com <span class="math notranslate nohighlight">\(\hat{T} \ket{u} = \ket{v}.\)</span> Vejamos agora, mais atentamente, sua ação dentro de um produto interno <span class="math notranslate nohighlight">\(\bra{w}v\rangle = \braket{w}{\hat{T}}{u}\)</span>. Sabemos que isso resulta num escalar (número) complexo.</p>
<p>Podemos tomar complexo conjugado desse número, usando a relação <span class="math notranslate nohighlight">\(\bra{w}v\rangle = \bra{v}w\rangle^*\)</span>. Observe atentamente o que ocorre com o operador</p>
<div class="math notranslate nohighlight">
\[
\braket{w}{\hat{T}}{v} = \braket{v}{\hat{T}}{w}^* =\braket{w}{\hat{T^{\dagger}}}{v}
\]</div>
<p>onde <span class="math notranslate nohighlight">\(\hat{T^{\dagger}}\)</span> (pronuncia-se “T <em>dagger</em>”) é chamado de conjugado Hermitiano, ou Hermitiano conjugado, ou ainda <strong>adjunto</strong> do operador <span class="math notranslate nohighlight">\(\hat{T}\)</span>.</p>
<p>!!! note “<strong>Como formar o Adjunto de uma expressão geral?</strong>”
1. Substitua qualquer constante por seu complexo conjugado.
2. Substitua <em>kets</em> pelos <em>bras</em> associados, e vice-versa.
3. Substitua cada operador por seu Adjunto.
4. Inverta a ordem de todos os fatores na expressão.</p>
<p><strong>O conjugado Hermitiano de uma matriz</strong></p>
<p>Já sabemos como encontrar a matriz <span class="math notranslate nohighlight">\(M\)</span> de um operador <span class="math notranslate nohighlight">\(\hat{M}\)</span> qualquer. Para encontrar a matriz do Adjunto desse, simbolizada por <span class="math notranslate nohighlight">\(M^{\dagger}\)</span>, basta seguir os seguintes passos:</p>
<p>!!! note “<strong>Matriz Adjunta</strong>”
1. Calcule a matriz transposta <span class="math notranslate nohighlight">\(M^T\)</span>, trocando as linhas pelas colunas.
2. Tome o complexo conjugado de cada elemento de <span class="math notranslate nohighlight">\(M^T.\)</span></p>
<p>De forma resumida:</p>
<div class="math notranslate nohighlight">
\[
M^{\dagger}= \left( M^T \right)^*.
\]</div>
<p><strong>Propriedade da operação de transposição</strong></p>
<p>!!! note “”
1. <span class="math notranslate nohighlight">\((A+B)^T = A^T + B^T.\)</span>
2. <span class="math notranslate nohighlight">\((A^T)^T = A.\)</span>
3. <span class="math notranslate nohighlight">\((aA)^T= a A^T.\)</span>
4. <span class="math notranslate nohighlight">\((AB)^T = B^T A^T.\)</span></p>
</section>
<section id="operadores-hermitianos">
<h3>Operadores Hermitianos<a class="headerlink" href="#operadores-hermitianos" title="Permalink to this heading">#</a></h3>
<p>Um operador é dito Hermitiano quando é auto-adjunto: <span class="math notranslate nohighlight">\(\hat{T}^{\dagger}=\hat{T}\)</span>. Isto é, quando o seu adjunto é ele próprio. Para um operador Hermitiano, temos que</p>
<div class="math notranslate nohighlight">
\[
\braket{w}{\hat{T}}{v}=\braket{v}{\hat{T}}{w}^*
\]</div>
<p>Veremos que os operadores de observáveis físicos na mecânica quântica devem ser sempre operadores Hermitianos. Como esse operadores podem ser representado por matrizes, é interessante ver com determinar se uma matriz é Hermitiana.</p>
<p><strong>Matriz Hermitiana</strong></p>
<p>Uma matriz <span class="math notranslate nohighlight">\(M\)</span> é Hermitiana se satisfaz:</p>
<div class="math notranslate nohighlight">
\[
M = M^{\dagger}.
\]</div>
<p>Como vimos, <span class="math notranslate nohighlight">\(M^{\dagger}\)</span> corresponde ao complexo conjugado da matriz transposta. Portanto, para satisfazer essa condição, os elementos da diagonal principal da matriz devem ser todos números reais (não complexos). Como consequência, o traço do operador (matriz) será, necessariamente um número real.</p>
<p><strong>Autovalores de um operador Hermitiano</strong></p>
<p>Pode-se demonstrar que operadores Hermitianos têm autovalores reais (<em>verifique!</em>). Por conta dessa propriedade, requer-se que todos os observáveis físicos na mecânica quântica, sejam representados por operadores Hermitianos. Portanto, tanto o traço como os autovalores de um operador Hermitiano são números reais.</p>
<p><strong>Autovetores de um operador Hermitiano</strong></p>
<p>Outra propriedade importante dos operadores Hermitianos é que os autovetores correspondentes a autovalores diferentes são ortogonais. Também não é difícil demonstrar essa propriedade (<em>verifique!</em>), usando a propriedade anterior, que os autovalores são números reais. Como os autovetores são ortogonais, é possível construir uma base (ortonormal) que gere o espaço.</p>
<p>!!! info “Propriedades de operadores Hermitianos”
1. Autovalores reais
2. Autovetores ortogonais, para autovalores diferentes
3. Autovetores geram o espaço (podem formar uma base)</p>
<p><strong>Operador anti-Hermitiano</strong></p>
<p>Um operador <span class="math notranslate nohighlight">\(\hat{A}\)</span> é dito anti-Hermitiano se:</p>
<div class="math notranslate nohighlight">
\[
A^{\dagger}=-A
\]</div>
<p>Verifique que, neste caso, os elementos da diagonal principal da matriz do operador anti-Hermitiano(a) são todos números imaginários puros.</p>
</section>
<section id="operadores-normais">
<h3>Operadores Normais<a class="headerlink" href="#operadores-normais" title="Permalink to this heading">#</a></h3>
<p>Um operador <span class="math notranslate nohighlight">\(A\)</span> é dito ser <em>normal</em> se ele comuta com seu adjunto:</p>
<div class="math notranslate nohighlight">
\[
AA^{\dagger} = A^{\dagger}A.
\]</div>
<p>Claramente, um operador Hermitiano é também um operador normal. Operadores normais são importantes pois há um <a class="reference external" href="https://en.wikipedia.org/wiki/Spectral_theorem">teorema</a> que garante que eles podem ser escritos na forma de <em>decomposição espectral</em>, que estudaremos adiante e será muito útil. Voltaremos a falar deles ao discutir o processo de diagonalização de um operador.</p>
</section>
<section id="operadores-unitarios">
<h3>Operadores Unitários<a class="headerlink" href="#operadores-unitarios" title="Permalink to this heading">#</a></h3>
<p>Um operador <span class="math notranslate nohighlight">\(\hat{U}\)</span> (de matriz <span class="math notranslate nohighlight">\(U\)</span>) é unitário se:</p>
<div class="math notranslate nohighlight">
\[
UU^{\dagger} = U^{\dagger} U = \mathbf{\hat{1}}
\]</div>
<p>Isso significa que</p>
<div class="math notranslate nohighlight">
\[
U^{\dagger} = U^{-1}
\]</div>
<p>ou seja, que a matriz adjunta é igual a matriz inversa.</p>
<p>Outra importante característica das matrizes unitárias é que as linhas e colunas dessa matrizes formam um conjunto de vetores ortonormais. Pode-se perceber ainda que operadores unitários também são operadores normais e, portanto, podem tem uma decomposição spectral, como veremos depois.</p>
<p>Finalmente, outra característica importante desses operadores é que geometricamente eles preservam o produto interno entre vetores, com pode ser facilmente verificado</p>
<div class="math notranslate nohighlight">
\[
( U\ket{v},U\ket{w}) = \bra{v}U^{\dagger}U\ket{w}=\braket{v}{\mathbf{\hat{1}}}{w}=\bra{v}w\rangle. 
\]</div>
</section>
<section id="comutadores-e-anticomutadores">
<h3>Comutadores e anticomutadores<a class="headerlink" href="#comutadores-e-anticomutadores" title="Permalink to this heading">#</a></h3>
<p>Seja <span class="math notranslate nohighlight">\(\hat{A}\)</span> e <span class="math notranslate nohighlight">\(\hat{B}\)</span> dois operadores lineares do espaço. Em geral, temos que <span class="math notranslate nohighlight">\(\hat{A}\hat{B} \ne \hat{B}\hat{A}.\)</span> Assim, define-se o comutador <span class="math notranslate nohighlight">\([\hat{A},\hat{B}]\)</span> como sendo</p>
<div class="math notranslate nohighlight">
\[
[\hat{A},\hat{B}] = \hat{A}\hat{B} - \hat{B}\hat{A}.
\]</div>
<p>Se <span class="math notranslate nohighlight">\([\hat{A},\hat{B}]=0\)</span>, dizemos que os operadores comutam. Dois operadores comutam se, e apenas se, eles compartilham uma mesma base de autovetores comuns.</p>
<p><strong>Propriedades do comutador</strong></p>
<p>!!! note “”
1. <span class="math notranslate nohighlight">\([A,B]=-[B,A]\)</span>
2. <span class="math notranslate nohighlight">\([A+B,C]=[A,C]+[B,C]\)</span>
3. <span class="math notranslate nohighlight">\([A,BC]=[A,B]C+B[A,C]\)</span>
4. Se <span class="math notranslate nohighlight">\(\hat{X}\)</span> e <span class="math notranslate nohighlight">\(\hat{P}\)</span> representam os operadores posição e momento linear, então <span class="math notranslate nohighlight">\([\hat{X}\)</span>, <span class="math notranslate nohighlight">\(\hat{P}]=i\hbar\)</span>, enquanto <span class="math notranslate nohighlight">\([\hat{X}\)</span>, <span class="math notranslate nohighlight">\(\hat{X}]= [\hat{P}\)</span>, <span class="math notranslate nohighlight">\(\hat{P}]=0.\)</span></p>
<p><strong>Anticomutador</strong></p>
<p>Define-se o anticomutador <span class="math notranslate nohighlight">\(\{\hat{A},\hat{B}\}\)</span> como sendo</p>
<div class="math notranslate nohighlight">
\[
\{ \hat{A},\hat{B} \} = \hat{A}\hat{B} + \hat{B}\hat{A}.
\]</div>
</section>
<section id="conjunto-completo-de-observaveis-que-comutam-ccoc">
<h3>Conjunto Completo de Observáveis que Comutam (CCOC)<a class="headerlink" href="#conjunto-completo-de-observaveis-que-comutam-ccoc" title="Permalink to this heading">#</a></h3>
<p>Um conjunto de operadores <span class="math notranslate nohighlight">\(\hat{A}\)</span>, <span class="math notranslate nohighlight">\(\hat{B}\)</span>, <span class="math notranslate nohighlight">\(\hat{C}, \dots\)</span> forma um CCCO se todos os subpares desses operadores comutam entre si.</p>
<div class="math notranslate nohighlight">
\[
[\hat{A},\hat{B}] = [\hat{B},\hat{C}] = [\hat{A},\hat{C}] = \dots= 0
\]</div>
<p>Isso implica que existe uma base comum de autovetores que é única para todos eles, exceto por um fator multiplicativo.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">7600042 - Tópicos Especiais em Mecânica Quântica (2023)</p>
      </div>
    </a>
    <a class="right-next"
       href="RevMQ-p2.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Estrutura matemática da MQ - parte 2</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espaco-de-estados">Espaço de estados</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espaco-vetorial-linear">Espaço vetorial linear</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#espacos-de-hilbert-espacos-vetoriais-da-mq">Espaços de Hilbert: espaços vetoriais da MQ</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Espaços de Hilbert: espaços vetoriais da MQ</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#produto-interno">Produto interno</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#comprimentos-e-angulos">Comprimentos e ângulos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#expansao-de-vetores">Expansão de vetores</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#notacao-de-dirac">Notação de Dirac</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#propriedades-do-produto-interno">Propriedades do produto interno</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vetores-de-base">Vetores de base</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#procedimento-de-gram-schmidt">Procedimento de Gram-Schmidt</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#algebra-de-dirac">Algebra de Dirac</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-lineares">Operadores lineares</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exemplos-importantes">Exemplos importantes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#representacao-de-operadores">Representação de operadores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#valores-esperados">Valores esperados</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#autovalores-e-autovetores">Autovalores e autovetores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjugacao-hermitiana">Conjugação Hermitiana</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-hermitianos">Operadores Hermitianos</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-normais">Operadores Normais</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operadores-unitarios">Operadores Unitários</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#comutadores-e-anticomutadores">Comutadores e anticomutadores</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#conjunto-completo-de-observaveis-que-comutam-ccoc">Conjunto Completo de Observáveis que Comutam (CCOC)</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Prof. Sérgio R. Muniz
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>